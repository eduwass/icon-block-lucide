#!/usr/bin/env node

/**
 * Generate register.js from Lucide icon SVG and JSON files
 * 
 * This script reads SVG files and their corresponding JSON metadata
 * from the dev/icons/lucide/ directory and generates a register.js
 * file with proper categories and tags for the Icon Block plugin.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { optimize } from 'svgo';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const pluginRoot = path.resolve(__dirname, '../..');
const lucideIconsDir = path.join(pluginRoot, 'dev/icons/lucide');
const lucideLabIconsDir = path.join(pluginRoot, 'dev/icons/lucide-lab');
const outputFile = path.join(pluginRoot, 'register.js');

console.log('üöÄ Generating register.js from Lucide icons...\n');

/**
 * Read and process icons from a directory
 */
function processIconsFromDirectory(directory, source = 'lucide') {
	const icons = [];
	const files = fs.readdirSync(directory);
	const svgFiles = files.filter(f => f.endsWith('.svg'));

	console.log(`üìÅ Processing ${svgFiles.length} icons from ${source}...`);

	svgFiles.forEach(file => {
		const baseName = path.basename(file, '.svg');
		const svgPath = path.join(directory, file);
		const jsonPath = path.join(directory, `${baseName}.json`);

		// Read SVG
		let svgContent = fs.readFileSync(svgPath, 'utf8');

		// Optimize SVG
		const { data: optimized } = optimize(svgContent, {
			path: svgPath,
			multipass: true,
			plugins: [
				{
					name: 'preset-default',
					params: {
						overrides: {
							removeViewBox: false,
							// Keep important attributes
							removeUnknownsAndDefaults: {
								keepRoleAttr: true,
							},
						}
					}
				},
				// Remove dimensions to make icons responsive
				{
					name: 'removeDimensions',
				},
			],
		});

		// Read JSON metadata if it exists
		let categories = [];
		let keywords = [];
		
		if (fs.existsSync(jsonPath)) {
			try {
				const metadata = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
				categories = metadata.categories || [];
				keywords = metadata.tags || [];
			} catch (e) {
				console.warn(`‚ö†Ô∏è  Could not parse JSON for ${baseName}:`, e.message);
			}
		}

		// Convert name to title (e.g., "a-arrow-down" -> "A Arrow Down")
		// Escape single quotes in title
		const title = baseName
			.split('-')
			.map(word => word.charAt(0).toUpperCase() + word.slice(1))
			.join(' ')
			.replace(/'/g, "\\'");

		icons.push({
			name: baseName,
			title,
			icon: optimized,
			categories,
			keywords,
			source,
		});
	});

	return icons;
}

/**
 * Extract all unique categories from icons
 */
function extractCategories(icons) {
	const categoryMap = new Map();

	icons.forEach(icon => {
		icon.categories.forEach(cat => {
			if (!categoryMap.has(cat)) {
				// Convert category slug to title (e.g., "multimedia" -> "Multimedia")
				const title = cat
					.split('-')
					.map(word => word.charAt(0).toUpperCase() + word.slice(1))
					.join(' ');
				
				categoryMap.set(cat, title);
			}
		});
	});

	return Array.from(categoryMap.entries())
		.sort((a, b) => a[0].localeCompare(b[0]))
		.map(([name, title]) => ({ name, title }));
}

/**
 * Generate the register.js file content
 */
function generateRegisterJS(icons, categories) {
	const iconsJS = icons
		.map(icon => {
			const parts = [
				`\t\t\t\tname: '${icon.name}'`,
				`\t\t\t\ttitle: '${icon.title}'`,
				`\t\t\t\ticon: '${icon.icon.replace(/'/g, "\\'")}'`,
			];

			if (icon.categories.length > 0) {
				parts.push(`\t\t\t\tcategories: [${icon.categories.map(c => `'lucide-${c}'`).join(', ')}]`);
			}

			if (icon.keywords.length > 0) {
				const keywordsStr = icon.keywords.map(k => `'${k.replace(/'/g, "\\'")}'`).join(', ');
				parts.push(`\t\t\t\tkeywords: [${keywordsStr}]`);
			}

			// Lucide icons use stroke, not fill
			parts.push(`\t\t\t\thasNoIconFill: true`);

			return `\t\t\t{\n${parts.join(',\n')}\n\t\t\t}`;
		})
		.join(',\n');

	const categoriesJS = categories
		.map(cat => {
			return `\t\t\t{\n\t\t\t\tname: 'lucide-${cat.name}',\n\t\t\t\ttitle: __('${cat.title}', 'icon-block-lucide')\n\t\t\t}`;
		})
		.join(',\n');

	return `// Add custom Lucide icons to the Icon Block.
// This file is auto-generated by dev/scripts/generate-register.js
// Do not edit manually - run the script to regenerate.

wp.domReady(() => {
	const { __ } = wp.i18n;
	const { addFilter } = wp.hooks;

	function addLucideIcons(iconLibraries) {
		// Define our Lucide icon library
		const lucideLibrary = {
			type: 'lucide',
			title: __('Lucide', 'icon-block-lucide'),
			categories: [
${categoriesJS}
			],
			icons: [
${iconsJS}
			],
		};

		// Add our library to the existing libraries
		return [ ...iconLibraries, lucideLibrary ];
	}

	addFilter('iconBlock.icons', 'icon-block-lucide/add-lucide-library', addLucideIcons);
});
`;
}

// Main execution
try {
	// Process Lucide icons
	let allIcons = [];
	
	if (fs.existsSync(lucideIconsDir)) {
		const lucideIcons = processIconsFromDirectory(lucideIconsDir, 'lucide');
		allIcons = allIcons.concat(lucideIcons);
	} else {
		console.warn('‚ö†Ô∏è  Lucide icons directory not found. Run ./download-dev-icons.sh first.');
	}

	// Process Lucide Lab icons (optional)
	if (fs.existsSync(lucideLabIconsDir)) {
		const lucideLabIcons = processIconsFromDirectory(lucideLabIconsDir, 'lucide-lab');
		allIcons = allIcons.concat(lucideLabIcons);
	}

	if (allIcons.length === 0) {
		console.error('‚ùå No icons found. Please run ./download-dev-icons.sh first.');
		process.exit(1);
	}

	console.log(`\n‚úÖ Processed ${allIcons.length} total icons`);

	// Extract categories
	const categories = extractCategories(allIcons);
	console.log(`üìã Found ${categories.length} unique categories`);

	// Generate register.js
	const registerJS = generateRegisterJS(allIcons, categories);
	fs.writeFileSync(outputFile, registerJS, 'utf8');

	console.log(`\n‚úÖ Successfully generated ${outputFile}`);
	console.log(`üìä Stats:`);
	console.log(`   - ${allIcons.length} icons`);
	console.log(`   - ${categories.length} categories`);
	console.log(`\nüéâ Done! Your Icon Block plugin is ready to use.`);

} catch (error) {
	console.error('‚ùå Error generating register.js:', error);
	process.exit(1);
}
