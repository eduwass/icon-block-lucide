#!/usr/bin/env node

/**
 * Generate lucide-icons.php from Lucide icon SVG and JSON files
 * 
 * This script reads SVG files and their corresponding JSON metadata
 * from the dev/icons/lucide/ directory and generates a PHP file
 * with all icons in a structured array format for use in custom forms.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { optimize } from 'svgo';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const pluginRoot = path.resolve(__dirname, '../..');
const lucideIconsDir = path.join(pluginRoot, 'dev/icons/lucide');
const lucideLabIconsDir = path.join(pluginRoot, 'dev/icons/lucide-lab');
const outputFile = path.join(pluginRoot, 'lucide-icons.php');

console.log('ðŸš€ Generating lucide-icons.php from Lucide icons...\n');

/**
 * Escape string for PHP single-quoted strings
 */
function phpEscape(str) {
	return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

/**
 * Read and process icons from a directory
 */
function processIconsFromDirectory(directory, source = 'lucide') {
	const icons = [];
	const files = fs.readdirSync(directory);
	const svgFiles = files.filter(f => f.endsWith('.svg'));

	console.log(`ðŸ“ Processing ${svgFiles.length} icons from ${source}...`);

	svgFiles.forEach(file => {
		const baseName = path.basename(file, '.svg');
		const svgPath = path.join(directory, file);
		const jsonPath = path.join(directory, `${baseName}.json`);

		// Read SVG
		let svgContent = fs.readFileSync(svgPath, 'utf8');

		// Optimize SVG
		const { data: optimized } = optimize(svgContent, {
			path: svgPath,
			multipass: true,
			plugins: [
				{
					name: 'preset-default',
					params: {
						overrides: {
							removeViewBox: false,
							// Keep important attributes
							removeUnknownsAndDefaults: {
								keepRoleAttr: true,
							},
						}
					}
				},
				// Remove dimensions to make icons responsive
				{
					name: 'removeDimensions',
				},
			],
		});

		// Read JSON metadata if it exists
		let categories = [];
		let keywords = [];
		
		if (fs.existsSync(jsonPath)) {
			try {
				const metadata = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
				categories = metadata.categories || [];
				keywords = metadata.tags || [];
			} catch (e) {
				console.warn(`âš ï¸  Could not parse JSON for ${baseName}:`, e.message);
			}
		}

		// Convert name to title (e.g., "a-arrow-down" -> "A Arrow Down")
		const title = baseName
			.split('-')
			.map(word => word.charAt(0).toUpperCase() + word.slice(1))
			.join(' ');

		icons.push({
			name: baseName,
			title,
			icon: optimized,
			categories,
			keywords,
			source,
		});
	});

	return icons;
}

/**
 * Extract all unique categories from icons
 */
function extractCategories(icons) {
	const categoryMap = new Map();

	icons.forEach(icon => {
		icon.categories.forEach(cat => {
			if (!categoryMap.has(cat)) {
				// Convert category slug to title (e.g., "multimedia" -> "Multimedia")
				const title = cat
					.split('-')
					.map(word => word.charAt(0).toUpperCase() + word.slice(1))
					.join(' ');
				
				categoryMap.set(cat, title);
			}
		});
	});

	return Array.from(categoryMap.entries())
		.sort((a, b) => a[0].localeCompare(b[0]))
		.map(([name, title]) => ({ name, title }));
}

/**
 * Generate PHP array representation of an icon
 */
function generateIconArray(icon, indent = '\t\t\t') {
	const parts = [
		`${indent}'name' => '${phpEscape(icon.name)}'`,
		`${indent}'title' => '${phpEscape(icon.title)}'`,
		`${indent}'svg' => '${phpEscape(icon.icon)}'`,
	];

	if (icon.categories.length > 0) {
		const cats = icon.categories.map(c => `'${phpEscape(c)}'`).join(', ');
		parts.push(`${indent}'categories' => [${cats}]`);
	} else {
		parts.push(`${indent}'categories' => []`);
	}

	if (icon.keywords.length > 0) {
		const keywords = icon.keywords.map(k => `'${phpEscape(k)}'`).join(', ');
		parts.push(`${indent}'keywords' => [${keywords}]`);
	} else {
		parts.push(`${indent}'keywords' => []`);
	}

	return `${indent.slice(0, -1)}[\n${parts.join(',\n')}\n${indent.slice(0, -1)}]`;
}

/**
 * Generate the PHP file content
 */
function generatePHP(icons, categories) {
	const categoriesPHP = categories
		.map(cat => `\t\t\t['name' => '${phpEscape(cat.name)}', 'title' => '${phpEscape(cat.title)}']`)
		.join(',\n');

	const iconsPHP = icons
		.map(icon => generateIconArray(icon))
		.join(',\n');

	return `<?php
/**
 * Lucide Icons Registry
 * 
 * Auto-generated by dev/scripts/generate-php-registry.js
 * Do not edit manually - run the script to regenerate.
 * 
 * Contains ${icons.length} icons across ${categories.length} categories.
 */

// Polyfill for esc_attr when not in WordPress context
if (!function_exists('esc_attr')) {
	function esc_attr($text) {
		return htmlspecialchars($text, ENT_QUOTES, 'UTF-8');
	}
}

if (!function_exists('get_lucide_icons')) {
	/**
	 * Get all Lucide icons with metadata
	 * 
	 * @return array{categories: array, icons: array}
	 */
	function get_lucide_icons() {
		static $icons = null;
		
		// Cache the icons array to avoid rebuilding on every call
		if ($icons === null) {
			$icons = [
				'categories' => [
${categoriesPHP}
				],
				'icons' => [
${iconsPHP}
				]
			];
		}
		
		return $icons;
	}
}

if (!function_exists('get_lucide_icon')) {
	/**
	 * Get a specific Lucide icon by name
	 * 
	 * @param string $name Icon name (e.g., 'alarm-clock-check')
	 * @return array|null Icon data or null if not found
	 */
	function get_lucide_icon($name) {
		$icons = get_lucide_icons();
		
		foreach ($icons['icons'] as $icon) {
			if ($icon['name'] === $name) {
				return $icon;
			}
		}
		
		return null;
	}
}

if (!function_exists('render_lucide_icon')) {
	/**
	 * Render a Lucide icon SVG
	 * 
	 * @param string $name Icon name (e.g., 'alarm-clock-check')
	 * @param string $class CSS classes to add to the SVG
	 * @param int|string $size Size in pixels (adds width/height attributes)
	 * @return string SVG markup or empty string if icon not found
	 */
	function render_lucide_icon($name, $class = '', $size = null) {
		$icon = get_lucide_icon($name);
		
		if (!$icon) {
			return '';
		}
		
		$svg = $icon['svg'];
		
		// Add class attribute if provided
		if (!empty($class)) {
			$svg = str_replace('<svg', '<svg class="' . esc_attr($class) . '"', $svg);
		}
		
		// Add size attributes if provided
		if ($size !== null) {
			$svg = str_replace('<svg', '<svg width="' . esc_attr($size) . '" height="' . esc_attr($size) . '"', $svg);
		}
		
		return $svg;
	}
}

if (!function_exists('get_lucide_icons_by_category')) {
	/**
	 * Get all icons in a specific category
	 * 
	 * @param string $category Category name (e.g., 'time', 'devices')
	 * @return array Array of icons in the category
	 */
	function get_lucide_icons_by_category($category) {
		$icons = get_lucide_icons();
		$filtered = [];
		
		foreach ($icons['icons'] as $icon) {
			if (in_array($category, $icon['categories'], true)) {
				$filtered[] = $icon;
			}
		}
		
		return $filtered;
	}
}

if (!function_exists('search_lucide_icons')) {
	/**
	 * Search icons by name, title, or keywords
	 * 
	 * @param string $query Search query
	 * @return array Array of matching icons
	 */
	function search_lucide_icons($query) {
		$icons = get_lucide_icons();
		$query = strtolower($query);
		$results = [];
		
		foreach ($icons['icons'] as $icon) {
			// Search in name
			if (strpos(strtolower($icon['name']), $query) !== false) {
				$results[] = $icon;
				continue;
			}
			
			// Search in title
			if (strpos(strtolower($icon['title']), $query) !== false) {
				$results[] = $icon;
				continue;
			}
			
			// Search in keywords
			foreach ($icon['keywords'] as $keyword) {
				if (strpos(strtolower($keyword), $query) !== false) {
					$results[] = $icon;
					break;
				}
			}
		}
		
		return $results;
	}
}
`;
}

// Main execution
try {
	// Process Lucide icons
	let allIcons = [];
	
	if (fs.existsSync(lucideIconsDir)) {
		const lucideIcons = processIconsFromDirectory(lucideIconsDir, 'lucide');
		allIcons = allIcons.concat(lucideIcons);
	} else {
		console.warn('âš ï¸  Lucide icons directory not found. Run ./download-icons.sh first.');
	}

	// Process Lucide Lab icons (optional)
	if (fs.existsSync(lucideLabIconsDir)) {
		const lucideLabIcons = processIconsFromDirectory(lucideLabIconsDir, 'lucide-lab');
		allIcons = allIcons.concat(lucideLabIcons);
	}

	if (allIcons.length === 0) {
		console.error('âŒ No icons found. Please run ./download-icons.sh first.');
		process.exit(1);
	}

	console.log(`\nâœ… Processed ${allIcons.length} total icons`);

	// Extract categories
	const categories = extractCategories(allIcons);
	console.log(`ðŸ“‹ Found ${categories.length} unique categories`);

	// Generate PHP file
	const phpContent = generatePHP(allIcons, categories);
	fs.writeFileSync(outputFile, phpContent, 'utf8');

	console.log(`\nâœ… Successfully generated ${outputFile}`);
	console.log(`ðŸ“Š Stats:`);
	console.log(`   - ${allIcons.length} icons`);
	console.log(`   - ${categories.length} categories`);
	
	// Calculate file size
	const stats = fs.statSync(outputFile);
	const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2);
	console.log(`   - ${fileSizeMB} MB file size`);
	
	console.log(`\nðŸŽ‰ Done! Your PHP icon registry is ready to use.`);
	console.log(`\nðŸ’¡ Usage examples:`);
	console.log(`   - Get all icons: get_lucide_icons()`);
	console.log(`   - Get one icon: get_lucide_icon('alarm-clock-check')`);
	console.log(`   - Render icon: render_lucide_icon('alarm-clock-check', 'w-6 h-6')`);
	console.log(`   - Search icons: search_lucide_icons('clock')`);
	console.log(`   - Filter by category: get_lucide_icons_by_category('time')`);

} catch (error) {
	console.error('âŒ Error generating PHP file:', error);
	process.exit(1);
}
